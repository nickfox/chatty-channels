// ChattyChannels/ChattyChannels/GrokProvider.swift

import Foundation
import os.log

// MARK: - Grok DTOs (Specific to this provider)

// Note: The DTOs for Grok are based on the assumption of an OpenAI-compatible API.
// These should be verified against official xAI Grok API documentation if available.

/// Represents a single message in a chat conversation, formatted for the Grok API.
/// This structure assumes compatibility with OpenAI's message format.
private struct GrokChatMessage: Codable {
    /// The role of the entity sending the message (e.g., "system", "user", "assistant").
    let role: String
    /// The textual content of the message.
    let content: String
}

/// The request body structure for the Grok Chat API.
/// Assumes compatibility with OpenAI's chat completions request format.
private struct GrokChatRequest: Codable {
    /// The identifier of the Grok model to use.
    let model: String
    /// An array of ``GrokChatMessage`` objects, forming the conversation context.
    let messages: [GrokChatMessage]
    // Optional parameters like temperature, max_tokens, stream could be added here.
    // let stream: Bool?
}

/// The response structure from the Grok Chat API.
/// Assumes compatibility with OpenAI's chat completions response format.
private struct GrokChatResponse: Decodable {
    /// Represents one of the completion choices returned by the API.
    struct Choice: Decodable {
        /// Contains the actual message generated by the assistant.
        struct ChoiceMessage: Decodable {
            /// The role of the message sender, typically "assistant".
            let role: String?
            /// The textual content of the assistant's message.
            let content: String?
        }
        /// The assistant's message within this choice.
        let message: ChoiceMessage
        // let finish_reason: String? // Potential field for why generation stopped.
    }
    /// An array of completion choices.
    let choices: [Choice]
    // Other potential fields based on OpenAI compatibility:
    // let id: String?
    // let created: Int?
    // let model: String?
    // /// Token usage statistics.
    // struct Usage: Decodable {
    //     let prompt_tokens: Int
    //     let completion_tokens: Int
    //     let total_tokens: Int
    // }
    // let usage: Usage?
}

// MARK: - GrokProvider Implementation

/// An ``LLMProvider`` implementation for interacting with xAI's Grok API.
///
/// This class handles communication with the Grok API. It currently assumes an
/// API structure and authentication mechanism (Bearer token) similar to OpenAI's
/// Chat Completions API due to common industry practices for new LLM APIs.
///
/// - Important: The DTOs, endpoint, and authentication method are based on these
///   assumptions and **must be verified** against official xAI Grok API documentation
///   once available and accurate.
///
/// ## Configuration
/// - Default model: `"grok-1"`
/// - Default endpoint: `"https://api.x.ai/v1/chat/completions"` (Assumed)
///
/// ## Topics
/// ### Initializers
/// - ``init(apiKey:modelName:endpoint:)``
/// ### Conforming to LLMProvider
/// - ``sendMessage(_:systemPrompt:)``
final class GrokProvider: LLMProvider {
    private let apiKey: String
    private let modelName: String
    private let endpointURL: URL
    private let logger: Logger
    private let urlSession: URLSession // Added URLSession property

    /// The assumed default API endpoint for Grok chat completions.
    /// **Verification with official documentation is crucial.**
    private static let defaultEndpoint = "https://api.x.ai/v1/chat/completions"
    /// The assumed default Grok model.
    /// **Verification with official documentation is crucial.**
    private static let defaultModel = "grok-1"

    /// Initializes a new `GrokProvider`.
    /// - Parameters:
    ///   - apiKey: The API key for xAI Grok.
    ///   - modelName: Optional. The specific Grok model to use. Defaults to ``defaultModel``.
    ///   - endpoint: Optional. A custom endpoint URL for the Grok API. Defaults to ``defaultEndpoint``.
    ///   - urlSession: Optional. The URLSession instance to use. Defaults to `URLSession.shared`.
    init(apiKey: String, modelName: String? = nil, endpoint: String? = nil, urlSession: URLSession = .shared) { // Designated initializer
        self.apiKey = apiKey
        self.modelName = modelName ?? GrokProvider.defaultModel
        self.urlSession = urlSession // Store the session
        
        let urlString = endpoint ?? GrokProvider.defaultEndpoint
        guard let url = URL(string: urlString) else {
            fatalError("Invalid Grok endpoint URL constructed: \(urlString). This indicates a programming error with the default URL string or a malformed custom endpoint.")
        }
        self.endpointURL = url
        
        self.logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "ChattyChannelsApp",
                             category: "GrokProvider")
        logger.info("GrokProvider initialized. Model: '\(self.modelName)', Endpoint: '\(self.endpointURL.absoluteString)'")
        logger.warning("""
            GrokProvider is using assumed API details. Please verify endpoint, model names, DTOs, \
            and authentication against official xAI Grok documentation.
            """)
    }
    
    /// Required initializer for ``LLMProvider`` conformance. Uses `URLSession.shared`.
    convenience required init(apiKey: String, modelName: String?, endpoint: String?) {
        self.init(apiKey: apiKey, modelName: modelName, endpoint: endpoint, urlSession: .shared)
    }

    /// Sends a message to the Grok API.
    ///
    /// Constructs a request assuming an OpenAI-compatible structure, sends it to the
    /// configured Grok model and endpoint, and processes the response.
    ///
    /// - Parameters:
    ///   - input: The user's text message.
    ///   - systemPrompt: The system prompt to guide the AI's behavior.
    /// - Returns: The assistant's reply as a `String`.
    /// - Throws: A ``NetworkError`` if the request fails at any stage.
    func sendMessage(_ input: String, systemPrompt: String) async throws -> String {
        var request = URLRequest(url: endpointURL)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        // Assuming standard Bearer token authentication for Grok API.
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let grokRequest = GrokChatRequest(
            model: self.modelName,
            messages: [
                GrokChatMessage(role: "system", content: systemPrompt),
                GrokChatMessage(role: "user", content: input)
            ]
        )

        do {
            request.httpBody = try JSONEncoder().encode(grokRequest)
            logger.debug("Sending request to Grok. Body: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "Could not decode body for logging")")
        } catch {
            logger.error("Failed to encode Grok request: \(error.localizedDescription)")
            throw NetworkError.requestFailed("Encoding request for Grok failed: \(error.localizedDescription)")
        }
        
        logger.info("ðŸ”¼ Grok: Sending to model '\(self.modelName)'. User input: \"\(input, privacy: .public)\"")

        do {
            // Use the injected urlSession instance
            let (data, response) = try await self.urlSession.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                logger.error("No HTTPURLResponse received from Grok.")
                throw NetworkError.invalidResponse(0, "No HTTP response received from Grok.")
            }

            let rawResponseBody = String(data: data, encoding: .utf8) ?? "Â«empty or non-UTF8 response bodyÂ»"
            logger.debug("Grok raw response. Status: \(httpResponse.statusCode). Body: \(rawResponseBody, privacy: .sensitive)")

            guard (200...299).contains(httpResponse.statusCode) else {
                logger.error("Grok API returned an error. Status: \(httpResponse.statusCode). Body: \(rawResponseBody)")
                throw NetworkError.invalidResponse(httpResponse.statusCode, "Grok API Error: \(rawResponseBody)")
            }

            let decodedResponse: GrokChatResponse
            do {
                decodedResponse = try JSONDecoder().decode(GrokChatResponse.self, from: data)
            } catch {
                logger.error("Failed to decode Grok JSON response: \(error.localizedDescription). Raw body for context: \(rawResponseBody)")
                throw NetworkError.decodingFailed("Decoding Grok JSON response failed: \(error.localizedDescription). Response: \(rawResponseBody)")
            }

            guard let replyContent = decodedResponse.choices.first?.message.content, !replyContent.isEmpty else {
                logger.error("No message content found in Grok response or content is empty. Number of choices: \(decodedResponse.choices.count).")
                throw NetworkError.decodingFailed("No message content in Grok response or content was empty. Check API response structure.")
            }
            
            let trimmedReply = replyContent.trimmingCharacters(in: .whitespacesAndNewlines)
            logger.info("ðŸ”½ Grok: Received reply from model '\(self.modelName)'. Assistant: \"\(trimmedReply, privacy: .public)\"")
            return trimmedReply

        } catch let error as NetworkError {
            throw error
        } catch let urlError as URLError {
            logger.error("Grok URLSession error: \(urlError.localizedDescription), Code: \(urlError.code.rawValue)")
            throw NetworkError.networkUnreachable("Network communication error with Grok: \(urlError.localizedDescription) (Code: \(urlError.code.rawValue))")
        } catch {
            logger.error("An unknown error occurred during the Grok request: \(error.localizedDescription)")
            throw NetworkError.requestFailed("An unknown error occurred with Grok: \(error.localizedDescription)")
        }
    }
}