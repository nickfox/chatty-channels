# VU Meter Integration Plan (v0.7) - Active Probing Identification

**Overall Goal:** Get the VU meter in the `Control Room` Swift app working with real RMS data from `AIplayer` JUCE plugins, using an active probing method for track identification.

---

## Phase 1: Plugin (`AIplayer`) Modifications (C++/JUCE)

1.  **Temporary Instance ID:**
    *   On startup, each plugin instance generates and stores a unique temporary identifier (e.g., `juce::Uuid().toString()`, let's call this `tempInstanceID`).
    *   File: `AIplayer/AIplayer/Source/PluginProcessor.h` & `AIplayer/AIplayer/Source/PluginProcessor.cpp`
2.  **Logic Pro Track UUID Storage:**
    *   Add a member variable to store the official Logic Pro Track UUID (e.g., `juce::String logicTrackUUID;`), once assigned.
    *   File: `AIplayer/AIplayer/Source/PluginProcessor.h`
3.  **OSC Communication:**
    *   **Initial RMS Sending:** Before `logicTrackUUID` is known, send RMS data as:
        *   Address: `/aiplayer/rms_unidentified`
        *   Arguments: `(string tempInstanceID, float rmsValue)`
    *   **Assigned RMS Sending:** After `logicTrackUUID` is assigned, send RMS data as:
        *   Address: `/aiplayer/rms`
        *   Arguments: `(string logicTrackUUID, float rmsValue)`
    *   **Handle UUID Assignment Message:** Implement a handler in `oscMessageReceived` for:
        *   Address: `/aiplayer/track_uuid_assignment`
        *   Expected Arguments: `(string tempInstanceIDToMatch, string assignedLogicTrackUUID)`
        *   If `tempInstanceIDToMatch` matches the plugin's `tempInstanceID`, store `assignedLogicTrackUUID` into `this->logicTrackUUID`. Log this event.
    *   File: `AIplayer/AIplayer/Source/PluginProcessor.cpp` (modifying `sendRMSTelemetry()` and `oscMessageReceived()`)

---

## Phase 2: Control Room App Modifications (Swift/SwiftUI)

1.  **`TrackMappingService.swift`:**
    *   No changes needed to its core function: it already fetches all `TrackName:LogicTrackUUID` pairs from Logic Pro using AppleScript. This map is vital for the calibration process.
    *   File: `ChattyChannels/ChattyChannels/TrackMappingService.swift`
2.  **`AppleScriptService.swift` (Enhancements):**
    *   Integrate and refine AppleScript functionality for active track probing. This service will need methods like:
        *   `probeTrack(logicTrackUUID: String, frequency: Double, duration: Double) throws`
        *   This method would internally:
            *   Remember current global playback state.
            *   Mute all tracks except the one identified by `logicTrackUUID`.
            *   Ensure a "Test Oscillator" (or similar tone generator) is on the target track, configure its frequency/level, and enable it.
            *   Initiate brief playback if Logic isn't already playing.
            *   After `duration`, disable/remove the tone generator and restore original mute/playback states.
    *   Ensure robust error handling for these AppleScript operations.
    *   File: `ChattyChannels/ChattyChannels/AppleScriptService.swift`
3.  **`OSCService.swift`:**
    *   **Receive Unidentified RMS:** Handle `/aiplayer/rms_unidentified (string tempInstanceID, float rmsValue)`. Store these incoming RMS values temporarily, associated with their `tempInstanceID` and the OSC sender's IP/port.
    *   **Receive Identified RMS:** Handle `/aiplayer/rms (string logicTrackUUID, float rmsValue)`. Pass this to `LevelMeterService`.
    *   **Send UUID Assignment:** Provide a method like `sendUUIDAssignment(toPluginIP: String, port: Int, tempInstanceID: String, logicTrackUUID: String)` which sends the `/aiplayer/track_uuid_assignment` message.
    *   File: `ChattyChannels/ChattyChannels/OSCService.swift`
4.  **Calibration Logic (e.g., `CalibrationService.swift` - New or existing service):**
    *   Orchestrates the track identification process, likely triggered by a user action ("Start Calibration").
    *   **Workflow:**
        1.  Fetch all `(TrackName, logicTrackUUID)` pairs from `TrackMappingService`.
        2.  Initialize an empty map: `[tempInstanceID: logicTrackUUID]`.
        3.  For each `logicTrackUUID` in the list:
            a.  Instruct `OSCService` to clear any transient RMS data for `tempInstanceID`s.
            b.  Call `AppleScriptService.probeTrack(logicTrackUUID: currentTrackUUID, ...)`
            c.  During the probe duration, monitor (via `OSCService`) incoming `/aiplayer/rms_unidentified` messages.
            d.  Identify the `tempInstanceID` that shows significant RMS activity during this specific probe.
            e.  If a `tempInstanceID` is successfully correlated:
                i.  Add the mapping: `identifiedMappings[tempInstanceID] = currentTrackUUID`.
                ii. Call `OSCService.sendUUIDAssignment(...)` to inform the plugin.
            f.  Log success/failure for this track.
        4.  Provide results to the UI.
5.  **`LevelMeterService.swift`:**
    *   Primarily consumes identified RMS data: `updateLevel(logicTrackUUID: String, rmsValue: Float)`.
    *   Its internal storage should be keyed by `logicTrackUUID`.
    *   It will publish updates that `VUMeterView` and other UI components consume.
    *   File: `ChattyChannels/ChattyChannels/Services/LevelMeterService.swift`
6.  **UI (`ContentView.swift`, `VUMeterView.swift`):**
    *   Provide a button/mechanism to start the "Calibration Mode."
    *   Display feedback during and after calibration.
    *   `VUMeterView` displays levels based on data from `LevelMeterService`, keyed by `logicTrackUUID`. It might use `TrackMappingService` to display track names corresponding to these UUIDs.
    *   Files: `ChattyChannels/ChattyChannels/ContentView.swift`, `ChattyChannels/ChattyChannels/Views/VUMeter/VUMeterView.swift`

---

## Phase 3: OSC Reliability (Task T-05 from `plan.md`)

*   Focus on ensuring the `/aiplayer/track_uuid_assignment` message is reliably delivered. This might involve a simple ack/retry from the plugin or ensuring the `Control Room` app sends it multiple times if no identified RMS is seen from that plugin shortly after assignment.
*   For `/aiplayer/rms` messages, UDP's best-effort delivery is likely acceptable for VU meters.

---

## Phase 4: Testing & Refinement

*   **Plugin:** Test `tempInstanceID` generation, OSC message formats, and correct switching of RMS messages after UUID assignment.
*   **Control Room App:**
    *   Test `AppleScriptService` track probing robustness.
    *   Test calibration logic: accurate correlation of probes with `tempInstanceID`s.
    *   Test `OSCService` message handling and routing.
    *   Test `LevelMeterService` data updates.
*   **End-to-End:**
    *   Verify with multiple `AIplayer` instances on different tracks in Logic Pro.
    *   Ensure VU meters display correct levels for the correct tracks after calibration.
    *   Test edge cases (e.g., plugin added/removed during calibration, Logic Pro closed).

---

## Mermaid Diagram: Active Probing Identification & RMS Flow

```mermaid
sequenceDiagram
    participant User
    participant CRApp as Control Room App
    participant CalibSvc as CalibrationService
    participant ASvc as AppleScriptService
    participant OSCtlSvc as OSCService (Control Room)
    participant Plugin as AIplayer Plugin
    participant Logic as Logic Pro
    participant TMS as TrackMappingService
    participant LMS as LevelMeterService
    participant VU as VUMeterView

    User->>CRApp: Start Calibration
    CRApp->>CalibSvc: beginIdentification()
    CalibSvc->>TMS: getAllTrackUUIDs()
    TMS-->>CalibSvc: List of (TrackName, logicTrackUUID)

    loop For each logicTrackUUID
        CalibSvc->>ASvc: probeTrack(currentLogicTrackUUID)
        ASvc->>Logic: Mute others, Insert/Enable Tone Gen on currentTrackUUID
        Logic-->>Plugin: (Audio tone on track)
        Plugin->>OSCtlSvc: /aiplayer/rms_unidentified (tempInstanceID, rmsValue)
        ASvc->>Logic: Disable Tone Gen, Restore Mutes
        OSCtlSvc-->>CalibSvc: Relays RMS data with tempInstanceID
        Note over CalibSvc: Correlates probe with active tempInstanceID
        CalibSvc->>OSCtlSvc: sendUUIDAssignment(tempInstanceID, currentLogicTrackUUID)
        OSCtlSvc->>Plugin: /aiplayer/track_uuid_assignment (tempInstanceID, currentLogicTrackUUID)
        Plugin->>Plugin: Stores logicTrackUUID, switches sending mode
    end

    loop Normal Operation (after calibration)
        Plugin->>OSCtlSvc: /aiplayer/rms (logicTrackUUID, rmsValue)
        OSCtlSvc->>LMS: updateLevel(logicTrackUUID, rmsValue)
        LMS-->>VU: (Publishes update for logicTrackUUID)
        VU->>VU: Updates display
    end