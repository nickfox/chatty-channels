# v0.8 Plan: Telemetry v1.1 - FFT & Band-Energy Analysis

## Overview
Version 0.8 focuses on extending the telemetry system from simple RMS values to include frequency-domain analysis through FFT computation and band-energy extraction. This will enable the AI producer to make frequency-aware mixing decisions.

## Core Objectives
1. **Implement Lazy FFT Computation** (Task T-08)
   - Add FFT analysis to AIplayer plugin without impacting audio performance
   - Target <1% CPU usage per plugin at 44.1 kHz, 128 buffer
   - Compute only when requested or at reduced rate

2. **Band-Energy Telemetry Protocol** (Task T-09)
   - Design efficient 4-band energy representation
   - Keep payload under 32 bytes
   - Maintain <0.1% packet loss
   - Extend existing OSC protocol

## Technical Architecture

### 1. Plugin-Side FFT Implementation
```cpp
// New components in AIplayer
- FFTProcessor class using JUCE's dsp::FFT
- Circular buffer for windowed FFT input
- Background thread for FFT computation
- Band energy extractor (4 bands: low, low-mid, high-mid, high)
- Configurable FFT size (512, 1024, 2048)
- Windowing function (Hann, Blackman-Harris)
```

### 2. Band-Energy Definition
```
Band 1 (Low):      20 Hz - 250 Hz    (bass, kick)
Band 2 (Low-Mid):  250 Hz - 2 kHz    (vocals, snare, keys)
Band 3 (High-Mid): 2 kHz - 8 kHz     (presence, clarity)
Band 4 (High):     8 kHz - 20 kHz    (air, cymbals)
```

### 3. OSC Protocol Extension
```
Current: /aiplayer/rms [trackID, rmsValue]
New:     /aiplayer/telemetry [trackID, rmsValue, band1, band2, band3, band4]

Compact format (32 bytes total):
- trackID: 4 bytes (e.g., "TR1")
- rmsValue: 4 bytes (float32)
- band1-4: 4 bytes each (float32)
- OSC overhead: ~8 bytes
```

## Implementation Approach

### Phase 1: FFT Infrastructure (Week 1)
1. Add JUCE FFT processor to AIplayer
2. Implement circular buffer for audio samples
3. Create background thread for FFT computation
4. Add FFT size and window configuration
5. Implement basic frequency bin analysis

### Phase 2: Band-Energy Extraction (Week 1-2)
1. Define frequency bands based on mixing needs
2. Implement bin-to-band mapping
3. Calculate energy per band with proper scaling
4. Add A-weighting option for perceptual accuracy
5. Optimize for minimal CPU usage

### Phase 3: Telemetry Integration (Week 2)
1. Extend OSC message format
2. Update OSCListener to handle new format
3. Modify LevelMeterService to store band data
4. Ensure backward compatibility with v0.7
5. Add configuration for FFT on/off

### Phase 4: Performance Optimization (Week 3)
1. Profile CPU usage across multiple instances
2. Implement lazy computation triggers
3. Add configurable update rates
4. Optimize memory allocation
5. Test with 100+ plugin instances

## Performance Requirements
- **CPU**: <1% per plugin @ 44.1 kHz, 128 samples
- **Memory**: <1 MB additional per plugin
- **Latency**: FFT results within 100ms of audio
- **Accuracy**: ±1 dB band energy measurement
- **Network**: <0.1% packet loss at 24 Hz update rate

## Testing Strategy

### Unit Tests
- FFT accuracy against known signals
- Band energy calculation correctness
- CPU usage measurements
- Memory allocation tracking
- Thread safety verification

### Integration Tests
- Multi-plugin FFT performance
- OSC bandwidth utilization
- End-to-end telemetry flow
- Backward compatibility with v0.7
- Stress test with 100+ tracks

### Validation Tests
- Compare against reference analyzer (e.g., Voxengo SPAN)
- Verify band energy matches expected values
- Test with various audio content (music, speech, noise)
- Confirm no audio glitches or dropouts

## UI Considerations
While v0.8 focuses on backend telemetry, we should plan for future UI:
- No UI changes in v0.8 (data infrastructure only)
- Band data will be available for future spectrum displays
- Consider v0.9 for frequency visualization UI

## Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| FFT computation causes audio glitches | High | Use separate thread, ring buffer |
| Increased packet size causes drops | Medium | Optimize format, add compression |
| CPU usage exceeds target | High | Implement lazy computation, reduce FFT size |
| Band definitions don't match mixing needs | Low | Make bands configurable |
| Memory usage with many plugins | Medium | Share FFT resources where possible |

## Success Criteria
1. ✅ FFT implementation uses <1% CPU per plugin
2. ✅ Band energy data accurate within ±1 dB
3. ✅ Telemetry packet size ≤32 bytes
4. ✅ Packet loss remains <0.1%
5. ✅ No audio glitches or quality degradation
6. ✅ Successfully tested with 100+ plugin instances
7. ✅ Backward compatible with v0.7 systems

## Dependencies
- JUCE 7's dsp::FFT module
- Existing OSC infrastructure from v0.7
- Track mapping system from v0.7
- Current RMS telemetry pipeline

## Timeline
- **Week 1**: FFT infrastructure and basic implementation
- **Week 2**: Band energy extraction and telemetry integration
- **Week 3**: Performance optimization and testing
- **Week 4**: Final validation and documentation

## Future Considerations (v0.9+)
- Configurable frequency bands
- Peak frequency detection
- Spectral centroid calculation
- UI visualization components
- AI mixing suggestions based on frequency content

---

This plan builds on the solid foundation from v0.7 while addressing the performance-critical FFT implementation. The focus on lazy computation and efficient band-energy representation ensures scalability to professional project sizes.
